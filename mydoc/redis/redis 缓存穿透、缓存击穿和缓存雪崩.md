### redis 缓存穿透、缓存击穿和缓存雪崩

---

##### 1.缓存穿透

###### 解释

​	用户请求一个数据，但是缓存没有，于是请求直接打到数据库，发现数据库也没有，然后用户发起多次请求或者很多用户同时发起，导致数据库压力巨大。这就是缓存穿透。

###### 解决办法

* 参数校验，非法参数直接拦截返回

* 缓存空对象，当数据库也没有数据时，将返回的空对象缓存起来，设置一个较短的过期时间，如 20s

  * 但是这种方法会存在两个问题：
    - 如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；
    - 即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。

* 布隆过滤器

  ​        对所有可能查询的参数以 `hash` 形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询。

##### 2.缓存击穿

###### 解释

​	`redis` 中一个热点 `key` 在失效的同时，大量的请求过来，从而会全部到达数据库，压垮数据库。一个 `key` 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 `key` 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库

###### 解决办法

* 设置热点数据永不过期。
* 定时更新，比如这个热点数据的过期时间是 1h，那么每到 59 minutes 时，通过定时任务去更新这个热点 `key`，并重新设置其过期时间。

* 互斥锁，互斥锁简单来说就是在 `redis` 中根据 `key` 获得的 `value` 值为空时，先锁上，然后从数据库加载，加载完毕，释放锁。若其他线程也在请求该 `key`时，发现获取锁失败，则睡眠一段时间（比如 100 ms）后重试。`redis` 中的 `setnx` 可实现。

  ~~~python
  def lock(loid):
      key = get_lock_after_pay_key(loid)
      if vadd0.setnx(key, 1):
          vadd0.expire(key, A_DAY)
          return True
  
      return False
  ~~~

  

##### 3.缓存雪崩

###### 解释

缓存雪崩是指，`redis` 宕机。或者 `redis` 大量的 `key` 同时失效，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。

###### 解决办法

* 设置有效期均匀分布
* 数据预热，对于即将来临的大量请求，我们可以提前走一遍系统，将数据提前缓存在 `redis` 中，并设置不同的过期时间。
* 保证 `redis` 服务高可用，`redis`的哨兵模式和集群模式，为防止`redis`集群单节点故障，可以通过这两种模式实现高可用。