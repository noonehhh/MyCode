### redis 缓存穿透、缓存击穿和缓存雪崩

---

##### 1.缓存穿透

###### 解释

~~~
用户请求一个数据，但是缓存没有，于是请求直接打到数据库，发现数据库也没有，然后用户发起多次请求或者很多用户同时发起，
导致数据库压力巨大。这就是缓存穿透。
~~~

###### 解决办法

>1. 参数校验，非法参数直接拦截返回
>
>2. 缓存空对象，当数据库也没有数据时，将返回的空对象缓存起来，设置一个较短的过期时间，如 20s
>
>3. 但是这种方法会存在两个问题：
>
>   ​	（1）如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；
>
>   ​	（2）即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。
>
>4. 布隆过滤器
>
>​        对所有可能查询的参数以 `hash` 形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询。

##### 2.缓存击穿

###### 解释

~~~
redis中一个热点 key 在失效的同时，大量的请求过来，从而会全部到达数据库，压垮数据库。一个 key 非常热点，在不停的扛着大并发，
大并发集中对这一个点进行访问，当这个 `key` 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库
~~~

###### 解决办法

>1. 设置热点数据永不过期。
>2. 定时更新，比如这个热点数据的过期时间是 1h，那么每到 59 minutes 时，通过定时任务去更新这个热点 `key`，并重新设置其过期时间。
>3. 互斥锁，互斥锁简单来说就是在 `redis` 中根据 `key` 获得的 `value` 值为空时，先锁上，然后从数据库加载，加载完毕，释放锁。若其他线程也在请求该 `key`时，发现获取锁失败，则睡眠一段时间（比如 100 ms）后重试。`redis` 中的 `setnx` 可实现。

~~~python
def lock(loid):
    key = get_lock_after_pay_key(loid)
    if vadd0.setnx(key, 1):
        vadd0.expire(key, A_DAY)
        return True

    return False
~~~

##### 3.缓存雪崩

###### 解释

~~~
缓存雪崩是指，redis 宕机。或者 redis 大量的 key 同时失效，于是所有的请求都会达到存储层，
存储层的调用量会暴增，造成存储层也会挂掉的情况。
~~~

###### 解决办法

>1. 设置有效期均匀分布
>2. 数据预热，对于即将来临的大量请求，我们可以提前走一遍系统，将数据提前缓存在 `redis` 中，并设置不同的过期时间。
>3. 保证 `redis` 服务高可用，`redis`的哨兵模式和集群模式，为防止`redis`集群单节点故障，可以通过这两种模式实现高可用。
>
>