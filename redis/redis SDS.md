### SDS

##### 是什么

`Redis` 是用 `C` 语言开发完成的，但在 `Redis` 字符串中，并没有使用 `C` 语言中的字符串，而是用一种称为 `SDS`（`Simple Dynamic String`）的结构体来保存字符串。

##### 特点

* 可扩展

##### 结构

~~~c
# 类型 sds 是 char * 的别名
typedef char *sds;

struct sdshdr {
    # 用于记录 buf 中已使用空间的长度
    int len;
    
    # buf 中空闲空间的长度
    int free;
    
    # 存储实际内容
    char buf[];
}
~~~

##### SDS 优势

1. 常数复杂度获取字符串长度：C字符串并不记录自身的长度信息，获取长度需要重头到尾遍历字符串。SDS直接调用len即可。
2. 杜绝缓冲区溢出：C字符串长度不会改变，SDS如果发现空间不足，不会产生溢出，而是自动扩容。
3. 减少修改字符串时带来的内存重分配次数：

~~~
C怎么做？
	C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，
	程序都总要对保存这个C字符串的数组进行一次内存重分配操作。
	
redis怎么做？
	为了避免C字符串的这种缺陷，SDS使用空间预分配和惰性空间释放来改进这种频繁的内存重分配
	
1.空间预分配: 一种优化字符串增长的方式，每次空间扩展时，会额外分配一些内存空间。分配策略有两种
		(1) SDS的len小于1MB和SDS的len大于1MB。
		(2) 在SDS的len小于1MB时，预留扩充后多一倍的内存；
		SDS的len大于1MB时，额外分配一1MB。
	举个例子：一个字符串，如果扩充后len等于10KB，那么SDS会额外分配10KB给free；如果扩充后len等于2MB，那么SDS会额外分配1MB的free给SDS

2. 惰性空间释放：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节， 
   而是使用free属性将这些字节的数量记录起来，并等待将来使用。
~~~

4. 二进制安全：

   C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，所以C字符串不能保存像图片、音频、视频、压缩文件这样的二进制数据。SDS没有这些限制。

5. 兼容部分C字符串函数：遵循C字符串以空字符结尾的惯例。