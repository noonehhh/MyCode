### 索引

#### 什么是索引？

​	索引是一种用于快速查询和检索数据的数据结构。索引的本质是一种排好序的数据结构。常见的索引结构有: `BTree`， `B+Tree`和 `Hash`。

##### 1.普通索引

* 创建索引

  ~~~mysql
  create index test_index on test(col_name)
  
  alter table test add index test_index2(col_name)
  
  create table test(
  	id int not null,
  	username varchar(16) not null,
  	index test_index (username)
  )
  ~~~

*  删除索引

  ~~~mysql
  drop index test_index on test
  ~~~

##### 2.唯一索引

​	与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

* 创建唯一索引

  ~~~mysql
  create unique index test_index on test(col_name)
  
  alter table test add unique index test_index2(col_name)
  
  create table test(
  	id int not null,
  	username varchar(16) not null,
  	unique index test_index (username)
  )
  ~~~

* 删除唯一索引
  ~~~mysql
  drop unique index test_index on test
  ~~~

##### 3.联合索引

两个或更多个列上的索引被称作联合索引

~~~sql
create index test_index on test(col1,col2,col3)

SELECT * FROM test WHERE col1=“1” AND clo2=“2” AND clo4=“4”
这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。
~~~

###### 	最左匹配原则

即最左优先，在检索数据时从联合索引的最左边开始匹配。

##### 4.为什么要使用索引？

	1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
	
	2. 可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。
	
	3. 帮助服务器避免排序和临时表。
	
	4. 将随机`IO`变为顺序`IO`
	
	5. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

##### 5.索引的缺点

 - 创建索引和维护索引需要耗费许多时间：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 `SQL` 执行效率。
- 占用物理存储空间 ：索引需要使用物理文件存储，也会耗费一定空间。

##### 6.使用索引的注意事项

适合建立索引

```
1. 在经常需要搜索的列上，可以加快搜索的速度；

2. 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。

3. 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；

4. 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。

5. 在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；
```

不适合建立索引
```
1. 表记录太少。

2. 经常增删改的表。

3. 数据重复且分布平均的表字段，因此应该只为最经常查询和经常排序的数据列建立索引（如果某个数据列包含许多重复的内容，为它建立索引
就没有太大的实际效果）。

4. 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引
```

其他注意事项

```
1. 避免 where 子句中对字段施加函数，这会造成无法命中索引。

2. 在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。

3. 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes
视图来查询哪些索引从未被使用
```

### MySQL中的索引

​	`MySQL`索引使用的数据结构主要有`B+Tree`索引 和 `Hash`索引 。

##### Hash 索引

	对于哈希索引来说，底层的数据结构就是哈希表，单条记录查询的效率很高，时间复杂度为1，因此在绝大多数需求为单条记录查询的时候，
	可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree、B+Tree索引。

###### Hash索引的缺点

	Hash索引适合精确查找，但是范围查找不适合，因为存储引擎都会为每一行计算一个hash码，hash码都是比较小的，并且不同键值行的hash码通常是不一样的，
	hash索引中存储的就是Hash码，hash 码彼此之间是没有规律的，
	且 Hash 操作并不能保证顺序性，所以值相近的两个数据，Hash值相差很远，被分到不同的桶中。这就是为什么hash索引只能进行全职匹配的查询，
	因为只有这样，hash码才能够匹配到数据。
##### 聚簇索引和非聚簇索引

###### 聚簇索引

~~~
将数据存储与索引放到了一块，找到索引也就找到了数据，叶子结点即存储了真实的数据行，不再有另外单独的数据页。 在一张表上最多只能
创建一个聚集索引，因为真实数据的物理顺序只能有一种。
~~~

###### 非聚簇索引

~~~
表数据存储顺序与索引顺序无关，将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，
~~~

总结一下

~~~
聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引
页它为每一个数据行存储一条索引记录。
~~~

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg)

###### 工作原理（InnoDB）

~~~
InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，
则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。

若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在
主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）
~~~

###### 工作原理（MyISM）

~~~
MyISM 使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的
节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，
对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。
~~~

###### 聚簇索引的优点

>1. 当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。
>
>2. 当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。
>
>3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

###### 聚簇索引的缺点

>1. 维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片
>2. 表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢
>3. 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或由于页分裂导致数据存储不连续的时

##### 二叉查找树

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%911.png)

如上图即是一棵**二叉查找树**，它的特点是：

* 左子树键值小于根的键值，右子树键值大于根的键值

**性能**

* 对该二叉树节点进行查找发现深度为1的节点的查找次数为1，深度为2的查找次数为2，深度为n的节点的查找次数为n。
* 二叉排序树的查找效率比较高，是 `O(logn)`
* 但最差时候会是 `O(n)`，比如插入的元素是有序的，生成的二叉排序树就是一个链表，这种情况下，需要遍历全部元素才行

二叉查找树可以任意构造，如上图同样的几个数字还可以这样构造：

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%912.png)

**理论上讲二叉树查找树速度和比较次数都是最小的，为什么不用二叉查找树呢？**

因为我们要考虑磁盘`IO`的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少`IO`次数，对于树来说，`IO`次数就是树的高度，而“矮胖”就是`b`树的特征之一，**这在从磁盘中查找数据（先读取到内存、后查找）的过程中，可以减少磁盘 IO 的次数，从而提升查找速度。**它的每个节点最多包含`m`个孩子，`m`称为`b`树的阶，`m`的大小取决于磁盘页的大小。



##### 平衡二叉树

![](https://github.com/No8LaVine/MyCode/blob/master/images/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%911.png)

* **平衡二叉树**在**二叉查找树**的基础上满足任何节点的两个子树的高度差为1，如图，左边是一棵**平衡二叉树**它的任何节点的两个子树的高度差<=1；右边不是平衡二叉树，其根节点的左子树高度为3，而右子树高度为1。

**树的对比**

|            | 名称 | 特点                                        | 平衡性 | 查找性能                                          | 插入                                               | 删除                                                         | 优势                                         | 应用                                             |
| ---------- | ---- | ------------------------------------------- | ------ | ------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ | -------------------------------------------- | ------------------------------------------------ |
| 二叉查找树 | BST  | 索引树，由于构建不稳定，查找效率不稳定      | 无     | 不稳定，跟具体构建树相关，最好O(logn)，最差O（N） | 直接插入                                           | 删除的是叶子节点或只有左或右子树比较简单，如同时存在左右子树，那么要找到前驱或后继代替原先节点，再删除 | 性能高于线性查找                             | 暂未找到，欢迎补充                               |
| 平衡二叉树 | AVL  | 索引树，BST进化版，自平衡，查找效率稳定     | 有     | 最好最坏都是O(lgn)                                | 最多需要2次旋转                                    | 最多需要lgN次旋转（参考，本人未证实）                        | 高度平衡，进一步提升查询效率                 | 暂未找到，欢迎补充                               |
| 红黑树     | RBT  | 索引树，BST进化版，自平衡，查找效率相对稳定 | 有     | 基本维持在O(lgn),最坏比AVL略差(2lg(n+1))          | 最多需要2次旋转，3次变色                           | 最多需要3次旋转（参考，本人未证实）                          | 自平衡，进一步提升查询效率                   | Java中TreeSet和TreeMap，JDK 8以后，HashMap的设计 |
| B树        | ^    | 多路查找树，提升IO效率，索引树进化而来      | 有     | IO次数取决于高度，减少IO次数                      | 1.可以直接插入的情况2.插入后破环平衡，需要进行分裂 | 1.可以直接删除2.直接删除后破环平衡，先向左右子树“借”节点3.直接删除后破环平衡，左右子树“借”不到节点，合并子树 | 降低IO次数                                   | 文件系统索引和部分非关系型数据库，如MongoDB      |
| B+树       | ^    | 多路查找树，提升IO效率，B树进化版           | 有     | 进一步减少IO次数                                  | 类似B树                                            | 类似B树                                                      | 进一步降低IO次数，范围查询方便，查询性能稳定 | 大多关系型数据库使用B+树作为索引                 |

**各种树的介绍见：**

https://juejin.cn/post/6844903606408183815

https://www.huaweicloud.com/articles/1a25d561fbc1feae629fa67233021a79.html

##### BTree

**BTree与哈希索引的区别**

~~~
1）B+tree的索引：
　　　　是按照顺序存储的，所以，如果按照B+tree索引，可以直接返回，带顺序的数据，但这个数据只是该索引列含有的信息。因此是顺序I/O
　　　　适用于： 精确匹配 、范围匹配 、最左匹配
2）Hash索引：
　　　　索引列值的哈希值+数据行指针：因此找到后还需要根据指针去找数据，造成随机I/O
　　　　适合： 精确匹配
　　　　不适合： 模糊匹配 、范围匹配 、不能排序
~~~

**其他概念**

* **扇区：磁盘的最小存储单位；**
* **磁盘块：文件系统读写数据的最小单位；**
* **页：内存的最小存储单位；
  联系
  一个磁盘块由连续几个（2^n）扇区组成；
  页的大小为磁盘块大小的2^n倍；
  查看
  页大小查看： getconf PAGE_SIZE，常见为4K；
  磁盘块大小查看：stat /boot/|grep “IO Block”，常见为4K；
  扇区大小查看：fdisk -l，常见为512Byte**；

**磁盘相关知识**

* 系统从磁盘读取数据到内存时是以磁盘块，为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。
* `InnoDB`存储引擎中有页的概念，页是内存读取的最小单位。`InnoDB`存储引擎中默认每个页的大小为`16KB`，可通过参数`innodb_page_size`将页的大小设置为`4K、8K、16K`，在`MySQL`中可通过如下命令查看页的大小：`mysql> show variables like 'innodb_page_size';`
* 而系统一个磁盘块的存储空间往往没有这么大，因此`InnoDB`每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小`16KB`。`InnoDB`在把磁盘数据读入到内存时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘`I/O`次数，提高查询效率



**BTree结构的数据可以让系统高效的找到数据所在的磁盘块**

![](https://github.com/No8LaVine/MyCode/blob/master/images/BTree.png)

**`BTree`每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小**



**特点**

~~~
为了描述`BTree`，首先定义一条数据记录为一个二元组[key, data]，`key`为记录的键值，对于不同数据记录，`key`是互不相同的；
`data`为数据记录除`key`外的数据。那么`BTree`是满足下列条件的数据结构：

1. 每个节点最多有m个孩子。 

2. 除了根节点和叶子节点外，中间节点至少有Ceil(m/2)个孩子。 

3. 若根节点不是叶子节点，则至少有2个孩子 

4. 所有叶子节点都在同一层，且不包含其它关键字信息 

5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 

6. 关键字的个数n满足：`ceil(m/2)-1 <= n <= m-1` 

7. ki(i=1,…n)为关键字，且关键字升序排序。 

8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)
~~~

**B树中如何查找数据**

~~~
因为 B 树的子树大小排序规则，因此在 B 树中查找数据时，一般需要这样：

1.从根节点开始，如果查找的数据比根节点小，就去左子树找，否则去右子树

2.和子树的多个关键字进行比较，找到它所处的范围，然后去范围对应的子树中继续查找

3.以此循环，直到找到或者到叶子节点还没找到为止
~~~

**举例**

**以一个3阶的BTree举例**![](https://github.com/No8LaVine/MyCode/blob/master/images/3%E9%98%B6%E4%BA%8C%E5%8F%89%E6%A0%91.png)

1. 每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。
2. 两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。
3. 以根节点为例，关键字为17和35，`P1`指针指向的子树的数据范围为小于17，`P2`指针指向的子树的数据范围为17~35，`P3`指针指向的子树的数据范围为大于35。

**模拟查找关键字29的过程**

~~~
'''模拟查找关键字29的过程：'''
根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】

比较关键字29在区间（17,35），找到磁盘块1的指针P2。
根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】

比较关键字29在区间（26,30），找到磁盘块3的指针P2。
根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】

在磁盘块8中的关键字列表中找到关键字29。
~~~

**BTree如何保证平衡**

~~~
平衡二叉树的平衡条件是：左右子树的高度差不大于 1；而 B 树的平衡条件则有三点：
1.叶子节点都在同一层

2.每个节点的关键字数为子树个数减一（子树个数 k 介于树的阶 M 和它的二分之一

3.子树的关键字保证左小右大的顺序
~~~

也就是说，一棵 3 阶的 B 树（即节点最多有三个子树），每个节点的关键字数最少为 1，最多为 2，如果要添加数据的子树的关键字数已经是最多，就需要**拆分节点，调整树的结构。**

https://juejin.cn/post/6844903613915987975

##### B+Tree

![](https://github.com/No8LaVine/MyCode/blob/master/images/B%2BTree.jpg)

由图可看出`B+Tree`的特点 同时也是 `BTree` 和 `B+Tree`的区别

~~~
1，所有关键字存储在叶子节点，非叶子节点不存储真正的data

2，为所有叶子节点增加了一个链指针

3，层级更低，IO 次数更少

4，每次都需要查询到叶子节点，查询性能稳定

5，叶子节点形成有序链表，范围查询方便

B +树的每个节点可以包含更多节点，其原因有两个：
	1.其一是降低树的高度(索引不会全部存储在内存中,内存中可能撑不住,所以一般都是将索引树存储在磁盘中，只是将根节点放到内存中，
	这样对每个节点的访问,实际上就是访问磁盘,树的高度就等于每次查询数据时磁盘 IO 操作的次数)
	
	2.另一种是将数据范围更改为多个间隔。间隔越大，数据检索越快(可以想象跳表)
~~~



**`BTree`的缺点**

~~~
1.B+Tree是在BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

2.从上一节中的BTree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。

3.而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小

4.当存储的数据量很大时同样会导致BTree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。

5.在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息， 
这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。
~~~

##### BTree/B+Tree区别

> 1）非叶子节点只存储键值信息。
> 2）数据记录都存放在叶子节点中
> 3）`B+Tree`的所有关键字存储在叶子节点，非叶子节点不存储真正的`data`。
> 4）`B+Tree`为所有叶子节点增加了一个链指针。
> 5）`B+Tree`支持叶子节点的延展性（横向性）

**B+tree(以每个节点可存4个建值及指针信息为例)**

~~~
1.B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息

2.在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。

3.因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。
~~~

![](https://github.com/No8LaVine/MyCode/blob/master/images/B%2BTree2.png)

**B+Tree优点**

~~~
1. B+树的磁盘IO代价更低：B+树非叶子节点没有指向数据行的指针，所以相同的磁盘容量存储的节点数更多，相应的IO读写次数肯定减少了。

2. B+树的查询效率更加稳定：由于所有数据都存于叶子节点。所有关键字查询的路径长度相同，每一个数据的查询效率相当。

3. 所有的叶子节点形成了一个有序链表，更加便于查找。

4. 数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引

5. 聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。

6. 辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。

7. 当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。
~~~



##### MyISAM和InnoDB实现BTree索引方式的区别

	MyISAM
		1.B+Tree叶节点的data域存放的是数据记录的地址。
		
		2.在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，
		
		然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
		
	InnoDB
		1.其数据文件本身就是索引文件。
		
		2.相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这
		个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”
		
		3.而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。
		
		4.在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。
		
	    5.因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 

​	

##### 为什么MongoDB使用B-Tree,Mysql使用B+Tree ?		

~~~
B +树中的非叶子节点不存储数据，并且存储在叶节点中的所有数据使得查询时间复杂度固定为log n。B树查询时间复杂度不是固定的，
它与键在树中的位置有关，最好是O(1)。
~~~

**我们已经说过，尽可能少的磁盘IO是提高性能的有效方法。MongoDB是一个聚合数据库，而B树恰好是键域和数据域的集群。**

**MongoDB**

~~~
至于为什么MongoDB使用B树而不是B +树，可以从其设计的角度考虑它。 MongoDB不是传统的关系数据库，而是以BSON格式(可以认为是JSON)存储的nosql
目的是高性能，高可用性和易于扩展。
~~~

**Mysql**

~~~
Mysql是关系型数据库，最常用的是数据遍历操作(join)，而MongoDB它的数据更多的是聚合过的数据，不像Mysql那样表之间的关系那么强烈,
因此MongoDB更多的是单个查询。
~~~

~~~
由于Mysql使用B+树，数据在叶节点上,叶子节点之间又通过双向链表连接,更加有利于数据遍历，而MongoDB使用B树,所有节点都有一个数据字段。
只要找到指定的索引，就可以对其进行访问。毫无疑问，单个查询MongoDB平均查询速度比Mysql快。
~~~

##### 其他相关问题

[其他](https://cloud.tencent.com/developer/article/1694711)

##### 各种索引类型的区别

​	**主键索引**：非空唯一索引

​	**唯一索引**：索引值唯一，允许有空值

​	**普通索引**：基本的索引，没有限制

​	**全文索引**：用于 `MyISAM` ，针对大数据，较耗时

​	**联合索引**：多个键组合为索引，遵循”最左前缀“原则

##### 索引优化

`EXPLAIN`用来分析`SQL`语句，用于显示`SQL`执行的详细信息

[美团-MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)

https://juejin.cn/post/6867180058549682184



真牛：

https://www.cnblogs.com/hollischuang/p/11155447.html











参考：

https://zhuanlan.zhihu.com/p/77383599