### golang 栈空间管理

#### 栈内存空间

~~~
Go 语言使用用户态线程 Goroutine 作为执行上下文，它的额外开销和默认栈大小都比线程小很多，然而 Goroutine 的
栈内存空间和栈结构也在早期几个版本中发生过一些变化：
~~~

>1. v1.0 ~ v1.1 — 最小栈内存空间为 4KB；
>2. v1.2 — 将最小栈内存提升到了 8KB；
>3. v1.3 — 使用**连续栈**替换之前版本的分段栈；
>4. v1.4 — 将最小栈内存降低到了 2KB[9]；

#### 分段栈

~~~
分段栈实现了一种不连续但是可以持续增长的栈，开始时，栈只有一个段，当需要更多的栈空间时，会分配一个新的段，和上一个栈双向链接。
这样，一个栈就是由多个双向链接的段所组成的。当新分配的段使用完毕后，新段会被释放掉。
~~~

##### 带来的问题

分段栈机制虽然能够按需为当前 Goroutine 分配内存并且及时减少内存的占用，但是它也存在两个比较大的问题：

> 1. 如果当前 Goroutine 的栈几乎充满，那么任意的函数调用都会触发栈扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为**热分裂**问题（Hot split）；
> 2. 一旦 Goroutine 使用的内存**越过**了分段栈的扩缩容阈值，运行时会触发栈的扩容和缩容，带来额外的工作量；

#### 连续栈

~~~
连续栈可以解决分段栈中存在的两个问题，其核心原理是每当程序的栈空间不足时，初始化一片更大的栈空间并将
原栈中的所有值都迁移到新栈中，新的局部变量或者函数调用就有充足的内存空间。使用连续栈机制时，栈空间不
足导致的扩容会经历以下几个步骤：
~~~

> 1. 在内存空间中分配更大的栈内存空间；
> 2. 将旧栈中的所有内容复制到新栈中；
> 3. **将指向旧栈对应变量的指针重新指向新栈**；
> 4. 销毁并回收旧栈的内存空间；

##### 重点

~~~
在扩容的过程中，最重要的是调整指针的第三步，这一步能够保证指向栈的指针的正确性，因为栈中的所有变量内存都会发生变化，
所以原本指向栈中变量的指针也需要调整。我们在前面提到过经过逃逸分析的 Go 语言程序的遵循以下不变性 —— 指向栈对象的指针
不能存在于堆中，所以指向栈中变量的指针只能在栈上，我们只需要调整栈中的所有变量就可以保证内存的安全了。
~~~

**连续栈的内存布局**

因为需要拷贝变量和调整指针，连续栈增加了栈扩容时的额外开销，但是通过合理栈缩容机制就能避免热分裂带来的性能问题，在 GC 期间如果 Goroutine 使用了栈内存的四分之一，那就将其内存减少一半，这样在栈内存几乎充满时也只会扩容一次，不会因为函数调用频繁扩缩容。



参考：

https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#73-%E6%A0%88%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86

https://zhuanlan.zhihu.com/p/46532477

https://zhuanlan.zhihu.com/p/28484133

https://tonybai.com/2014/11/05/how-stacks-are-handled-in-go/