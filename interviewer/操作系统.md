[网络 IO 演变发展过程和模型介绍](https://mp.weixin.qq.com/s/EDzFOo3gcivOe_RgipkTkQ)

###### [同步、异步、阻塞、非阻塞](https://www.cnblogs.com/loveer/p/11479249.html)

#### 用户空间和内核空间

>现在操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）
>
>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。
>
>为了保证用户进程不能直接操作内核（内核），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。

~~~
针对 linux 操作系统而言，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，
而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF ），供各个进程使用，称为用户空间。
~~~

#### 系统调用

~~~
我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！
~~~

也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如**文件管理、进程控制、内存管理**等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

这些系统调用按功能大致可分为如下几类：

>1. 设备管理。完成设备的请求或释放，以及设备启动等功能。
>2. 文件管理。完成文件的读、写、创建及删除等功能。
>3. 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
>4. 进程通信。完成进程之间的消息传递或信号传递等功能。
>5. 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

#### 文件描述符

~~~
文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用
都会通过文件描述符。非负整数，一个索引值，指向内核为每个进程所维护的该进程打开文件的记录表，当进程打开一个
文件或者创建一个新文件时，内核向进程返回一个文件描述符。
~~~

#### 缓存 I/O

~~~
缓存 I/O 又被称作标准 I/O ，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，
操作系统会将 I/O 的数据缓存在文件系统的页缓存（page cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，
然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
~~~

##### 缓存 I/O 的缺点：

> 数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 `CPU` 以及内存开销是非常大的。

#### I/O模式

~~~
由上可知，对于一次 I/O 访问（以 read 为例），数据会被先拷贝到操作系统内核的缓冲区中，然后才从内核缓冲区拷贝到
应用程序的地址空间，所以说当一个 read 操作发生时，会经历两个阶段：

​ 1.等待数据准备	

​ 2.将数据从内核缓冲区拷贝到内核中
~~~

`Linux`系统由此诞生了五种网络模式：

##### 阻塞I/O

~~~
数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）
当内核一直等到数据准备好了，它就会将数据从内核中拷贝到用户内存，然后内核返回结果，用户进程才解除阻塞的状态，重新运行起来。
~~~

##### 非阻塞I/O

###### 读

~~~
当用户进程发出 read 操作时，如果内核中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回一个 error 。

从用户进程角度讲 ，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，
它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户进程的系统调用，
那么它马上就将数据拷贝到了用户内存，然后返回。

所以，nonblocking IO的特点是用户进程需要不断的主动询问内核数据好了没有。
~~~

###### 写

~~~
在 linux 下，应用程序可以通过设置文件描述符的属性 O_NONBLOCK ，IO 操作可以立即返回，但是并不保证 IO 操作成功。

也就是说，当应用程序设置了 O_NONBLOCK 之后，执行 write 操作，调用相应的系统调用，这个系统调用会从内核中立即返回。
但是在这个返回的时间点，数据可能还没有被真正的写入到指定的地方。也就是说，内核只是很快的返回了这个系统调用
（只有立马返回，应用程序才不会被这个 IO 操作阻塞），但是这个系统调用具体要执行的事情（写数据）可能并没有完成。

而对于应用程序，虽然这个 IO 操作很快就返回了，但是它并不知道这个 IO 操作是否真的成功了，为了知道 IO 操作是否成功，
一般有两种策略：
​ 1. 需要应用程序主动地循环地去问内核(这种方法就是同步非阻塞 IO )；
​ 2. 采用 IO 通知机制，比如： IO 多路复用(这种方法属于异步阻塞 IO )或信号驱动 IO (这种方法属于异步非阻塞 IO )。
~~~

##### I/O多路复用

> 目前支持`I/O`多路复用的系统调用有 `select，pselect，poll，epoll`，`I/O`多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但`select，pselect，poll，epoll`本质上都是同步`I/O`，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步`I/O`则无需自己负责进行读写，异步`I/O`的实现会负责把数据从内核拷贝到用户空间。

##### 信号驱动I/O

* 应用程序提交`read`请求的`system call`，然后，内核开始处理相应的`I/O`操作，而同时，应用程序并不等内核返回响应，就会开始执行其他的处理操作（应用程序没有被`I/O`操作所阻塞）。当内核执行完毕，返回`read`的响应，就会产生一个信号或执行一个基于线程的回调函数来完成这次 `IO` 处理过程。
* 从理论上说，阻塞`IO`、`IO`复用和信号驱动的`IO`都是同步`IO`模型。因为在这三种模型中，`IO`的读写操作都是在`IO`事件发生之后由应用程序来完成。而`POSIX`规范所定义的异步IO模型则不同。对异步IO而言，用户可以直接对`IO`执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及`IO`操作完成后内核通知应用程序的方式。异步`IO`读写操作总是立即返回，而不论`IO`是否阻塞的，因为真主的读写操作已经由内核接管。也就是说，同步`IO`模型要求用户代码自行执行`IO`操作(将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区)，而异步`IO`机制则是由内核来执行`IO`操作(数据在内核缓冲区和用户缓冲区之间的移动是由内核在后台完成的)。你可以这样认为，同步`IO`向应用程序通知的是`IO`就绪事件，而异步`IO`向应用程序通知的是`IO`完成事件。`linux`环境下，`aio.h`头文件中定义的函数提供了对异步`IO`的支持。

##### 异步I/O

* 用户进程发起`read`操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个`asynchronous read`之后，首先它会立刻返回，所以不会对用户进程产生任何`block`。然后，内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个`signal`，告诉它`read`操作完成了。

##### 进程间通信方式：分类、区别、优缺点、使用场景

| 分类     | 特点           | 具体通信方式                     |
| -------- | -------------- | -------------------------------- |
| 低级通信 | 控制信息的传送 | 信号                             |
| 高级通信 | 与大批数据传送 | 管道、消息队列、共享内存、套接字 |

| 通信方式            | 介绍                                                         | 区别                                                         | 优缺点                                                       | 使用场景                                                     |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 管道pipe            | 两种限制, 一是半双工,只能单向传输; 二是只能在父子进程间使用. |                                                              | 优：无名管道简单方便 缺：单项传输、只父子进程                | 只能在具有亲缘关系的进程间使用.一般指的是父子关系.管道一般用于两个不同进程之间的通信. |
| 流管道              | 双向传输. 只能在父子进程间使用                               |                                                              |                                                              | 只能在父子进程间使用                                         |
| 有名管道            | 单向传输； 可以在许多并不相关的进程之间进行通讯.             |                                                              | 优点：可以提供给任意关系的进程使用． 缺点：由于其长期存在于系统之中，使用不当容易出错．所以普通用户一般不建议使用 | 允许无亲缘关系进程间的通信                                   |
| 信号（Signal）      | 由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。 |                                                              | 优点：触发某些行为 缺点：传递信息少                          | 用户传递的信息较少；用于通知接收进程某个事件已经发生；发送信号给进程本身 |
| 信号量（semaphore） | 是一个特殊的变量，它的本质是计数器，信号量里面记录了临界资源的数目，有多少数目，信号量的值就为多少，进程对其访问都是原子操作（pv操作，p：占用资源，v：释放资源）。 它的作用就是，调协进程对共享资源的访问，让一个临界区同一时间只有一个进程在访问它。 主要作为进程间以及同一进程不同线程之间的同步手段 | 信号是通知进程产生了某个事件， 信号量是用来同步进程的        |                                                              | 用于多线程之间的同步，常与**共享内存**配合使用               |
| 消息队列 (Message)  | 消息队列是消息的链接表，包括Posix消息队列systemV消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。 允许任意进程通过共享消息队列来实现进程间通信．并由系统调用函数来实现消息发送和接收之间的同步．从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题 | 消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点 | 优点：不再局限于父子进程，不再需要考虑同步问题．使用方便 缺点：消息队列中信息的复制需要额外消耗CPU的时间．不适宜于信息量大或操作频繁的场合。 | 消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点. UNIX允许不同进程将格式化的数据流以消息队列形式发送给任意进程. |
| 共享内存            | 使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。 往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。 | 共享内存针对消息缓冲的缺点改而利用内存缓冲区直接交换信息     | 优点：无须复制，快捷、信息量大 缺点：1、通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的．因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决 2、由于内存实体存在于计算机系统中．所以只能由处于同一个计算机系统中的诸进程共享,不方便网络通信 | **与其他通信机制,如信号量**,配合使用,来实现进程间的同步与通信 |
| 套接口（Socket）    | 对于网站，通信模型是服务器与客户端之间的通信。两端都建立了一个 Socket 对象，然后通过 Socket 对象对数据进行传输。通常服务器处于一个无限循环，等待客户端的连接。 |                                                              |                                                              | 用于不同进程及其间进程的通信 ；不同计算机之间的通信          |



##### 问题合集

##### https://github.com/Snailclimb/JavaGuide/blob/master/docs/operating-system/basis.md

https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md

##### 互斥锁、自旋锁、读写锁、悲观锁、乐观锁

https://www.cnblogs.com/xiaolincoding/p/13675202.html

https://www.cnblogs.com/LiuYanYGZ/p/12739614.html

##### 进程的通信方式（我写过一篇很不错的文章：记一次面试：进程之间究竟有哪些通信方式？---- 告别死记硬背）

https://cloud.tencent.com/developer/article/1460670

##### 内存管理，包括：虚拟内存（重点）、分页、分段、分页系统地址映射、内存置换算法（重点）。

https://juejin.cn/post/6844903928501370893

##### 死锁的处理策略（死锁预防、死锁检测与恢复、死锁避免）

https://www.pianshen.com/article/73421220495/

https://www.cnblogs.com/cxuanBlog/p/13202898.html