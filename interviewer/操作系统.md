https://mp.weixin.qq.com/s/EDzFOo3gcivOe_RgipkTkQ

##### 概念

###### 同步、异步、阻塞、非阻塞

https://www.cnblogs.com/loveer/p/11479249.html

###### 用户空间和内核空间

现在操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 **4G**（2 的 32 次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（`kernel`），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对`linux`操作系统而言，将最高的 **1G** 字节（从虚拟地址`0xC0000000`到`0xFFFFFFFF`），供内核使用，称为内核空间，而将较低的 **3G** 字节（从虚拟地址`0x00000000`到`0xBFFFFFFF`），供各个进程使用，称为用户空间。

###### 系统调用

​	我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！

也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

这些系统调用按功能大致可分为如下几类：

- 设备管理。完成设备的请求或释放，以及设备启动等功能。
- 文件管理。完成文件的读、写、创建及删除等功能。
- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
- 进程通信。完成进程之间的消息传递或信号传递等功能。
- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

###### 文件描述符：

​		文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行`I/O`操作的系统调用都会通过文件描述符。非负整数，一个索引值，指向内核为每个进程所维护的该进程打开文件的记录表，当进程打开一个文件或者创建一个新文件时，内核向进程返回一个文件描述符。

###### 缓存 I/O

​	缓存 `I/O` 又被称作标准 `I/O`，大多数文件系统的默认 `I/O` 操作都是缓存 `I/O`。在 `Linux` 的缓存 `I/O` 机制中，操作系统会将 `I/O` 的数据缓存在文件系统的页缓存（ `page cache` ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。

**缓存 I/O 的缺点：**
	数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 `CPU` 以及内存开销是非常大的。

###### I/O模式

​	由上可知，对于一次`I/O`访问（以`read`为例），数据会被先拷贝到操作系统内核的缓冲区中，然后才从内核缓冲区拷贝到应用程序的地址空间，所以说当一个`read`操作发生时，会经历两个阶段：

​		**1.等待数据准备**	

​		**2.将数据从内核缓冲区拷贝到内核中**

`Linux`系统由此诞生了五种网络模式：

* 阻塞`I/O`

  * 数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当`kernel`一直等到数据准备好了，它就会将数据从`kernel`中拷贝到用户内存，然后`kernel`返回结果，用户进程才解除`block`的状态，重新运行起来。

* 非阻塞`I/O`

  * 读，当用户进程发出`read`操作时，如果`kernel`中的数据还没有准备好，那么它并不会`block`用户进程，而是立刻返回一个`error`。从用户进程角度讲 ，它发起一个`read`操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个`error`时，它就知道数据还没有准备好，于是它可以再次发送`read`操作。一旦`kernel`中的数据准备好了，并且又再次收到了用户进程的`system call`，那么它马上就将数据拷贝到了用户内存，然后返回。

    所以，`nonblocking IO`的特点是用户进程需要**不断的主动询问**`kernel`数据好了没有。

  * 写，在`linux`下，应用程序可以通过设置文件描述符的属性`O_NONBLOCK`，`IO`操作可以立即返回，但是并不保证`IO`操作成功。也就是说，当应用程序设置了`O_NONBLOCK`之后，执行`write`操作，调用相应的`system call`，这个`system call`会从内核中立即返回。但是在这个返回的时间点，数据可能还没有被真正的写入到指定的地方。也就是说，`kernel`只是很快的返回了这个 `system call`（只有立马返回，应用程序才不会被这个`IO`操作`blocking`），但是这个`system call`具体要执行的事情（写数据）可能并没有完成。而对于应用程序，虽然这个`IO`操作很快就返回了，但是它并不知道这个`IO`操作是否真的成功了，为了知道`IO`操作是否成功，一般有两种策略：一是需要应用程序主动地循环地去问`kernel`(这种方法就是同步非阻塞`IO`)；二是采用`IO`通知机制，比如：`IO`多路复用(这种方法属于异步阻塞`IO`)或信号驱动`IO`(这种方法属于异步非阻塞`IO`)。

* `I/O`多路复用

  * 目前支持`I/O`多路复用的系统调用有 `select，pselect，poll，epoll`，`I/O`多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但`select，pselect，poll，epoll`本质上都是同步`I/O`，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步`I/O`则无需自己负责进行读写，异步`I/O`的实现会负责把数据从内核拷贝到用户空间。

* 信号驱动`I/O`

  * 应用程序提交`read`请求的`system call`，然后，`kernel`开始处理相应的`I/O`操作，而同时，应用程序并不等`kernel`返回响应，就会开始执行其他的处理操作（应用程序没有被`I/O`操作所阻塞）。当`kernel`执行完毕，返回`read`的响应，就会产生一个信号或执行一个基于线程的回调函数来完成这次 `IO` 处理过程。
  * 从理论上说，阻塞`IO`、`IO`复用和信号驱动的`IO`都是同步`IO`模型。因为在这三种模型中，`IO`的读写操作都是在`IO`事件发生之后由应用程序来完成。而`POSIX`规范所定义的异步IO模型则不同。对异步IO而言，用户可以直接对`IO`执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及`IO`操作完成后内核通知应用程序的方式。异步`IO`读写操作总是立即返回，而不论`IO`是否阻塞的，因为真主的读写操作已经由内核接管。也就是说，同步`IO`模型要求用户代码自行执行`IO`操作(将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区)，而异步`IO`机制则是由内核来执行`IO`操作(数据在内核缓冲区和用户缓冲区之间的移动是由内核在后台完成的)。你可以这样认为，同步`IO`向应用程序通知的是`IO`就绪事件，而异步`IO`向应用程序通知的是`IO`完成事件。`linux`环境下，`aio.h`头文件中定义的函数提供了对异步`IO`的支持。

* 异步`I/O`

  * 用户进程发起`read`操作之后，立刻就可以开始去做其它的事。而另一方面，从`kernel`的角度，当它受到一个`asynchronous read`之后，首先它会立刻返回，所以不会对用户进程产生任何`block`。然后，`kernel`会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，`kernel`会给用户进程发送一个`signal`，告诉它`read`操作完成了。



##### 1. select、poll、epoll

https://segmentfault.com/a/1190000003063859

http://www.mianshigee.com/question/10256gqt

https://www.modb.pro/db/28290

https://www.ktanx.com/blog/p/4706

##### 2.问题合集

##### https://github.com/Snailclimb/JavaGuide/blob/master/docs/operating-system/basis.md

https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md

##### 3.互斥锁、自旋锁、读写锁、悲观锁、乐观锁

https://www.cnblogs.com/xiaolincoding/p/13675202.html

https://www.cnblogs.com/LiuYanYGZ/p/12739614.html

##### 进程的通信方式（我写过一篇很不错的文章：记一次面试：进程之间究竟有哪些通信方式？---- 告别死记硬背）

https://cloud.tencent.com/developer/article/1460670

##### 内存管理，包括：虚拟内存（重点）、分页、分段、分页系统地址映射、内存置换算法（重点）。

https://juejin.cn/post/6844903928501370893

##### 死锁的处理策略（死锁预防、死锁检测与恢复、死锁避免）

https://www.pianshen.com/article/73421220495/

https://www.cnblogs.com/cxuanBlog/p/13202898.html